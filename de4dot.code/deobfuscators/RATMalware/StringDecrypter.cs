using System;
using System.Collections.Generic;
using System.Linq;
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using de4dot.blocks;

namespace de4dot.code.deobfuscators.RATMalware {
	class StringDecrypter {
		readonly ModuleDefMD _module;

		readonly MethodDefAndDeclaringTypeDict<StringDecrypterInfo> _stringDecrypterMethods = new();

		private class StringDecrypterInfo {
			public readonly MethodDef Method;
			public string Key;
			public StringDecrypterInfo(MethodDef method) => Method = method;
		}

		public bool Detected => _stringDecrypterMethods.Count > 0;

		public IEnumerable<MethodDef> StringDecrypters => _stringDecrypterMethods.GetKeys();

		public StringDecrypter(ModuleDefMD module) => _module = module;

		public void Find() {
			foreach (var type in _module.GetTypes()) {
				FindStringDecrypterMethods(type);
			}
		}

		void FindStringDecrypterMethods(TypeDef type)
		{
			foreach (var method in DotNetUtils.FindMethods(type.Methods, "System.String",
				         new[] { "System.String" })) {
				if (!DotNetUtils.CallsMethod(method, "System.Char Microsoft.VisualBasic.Strings::Chr(System.Int32)")
				    || !DotNetUtils.CallsMethod(method, "System.Int32 Microsoft.VisualBasic.Strings::Asc(System.Char)")
				    || !DotNetUtils.CallsMethod(method, "System.Byte[] System.Convert::FromBase64String(System.String)"))
					continue;

				// We don't look for the key string here right away, because it might still be encoded.
				var info = new StringDecrypterInfo(method);
				_stringDecrypterMethods.Add(info.Method, info);
				Logger.v("Found string decrypter method " + Utils.RemoveNewlines(info.Method));
			}
		}

		/**
		 * This callback is called for each call to one of the string decrypter methods.
		 */
		public string Decrypt(MethodDef method, string str) {
			var info = _stringDecrypterMethods.Find(method);
			if (info == null)
				throw new ArgumentException("Passed method is not a string decrypter");

			var key = info.Key;

			var bytes = Convert.FromBase64String(str);
			var chrArr = new char[bytes.Length];
			int i = 0, keyIndex = 0;
			foreach (byte b in bytes) {
				chrArr[i++] = (char)(b ^ (byte)key[keyIndex]);
				keyIndex = (keyIndex + 1) % key.Length;
			}

			return string.Intern(new string(chrArr));
		}

		/**
		 * Should be called to associate a decrypter method with its key, once it has been decrypted.
		 * We assume the key is simply the first ldstr instruction.
		 */
		public void ObtainKey(MethodDef method, Blocks blocks) {
			var info = _stringDecrypterMethods.Find(method);
			if (info == null) throw new ArgumentException("Passed method is not a string decrypter");

			foreach (var block in blocks.MethodBlocks.GetAllBlocks()) {
				foreach (var instr in block.Instructions.Where(instr => instr.OpCode.Code == Code.Ldstr))
				{
					info.Key = instr.Operand as string;
					return;
				}
			}

			throw new Exception("Could not obtain key for " + method.FullName);
		}
	}
}
